#ifdef _PERMUTATION0_
    #define _COSMASK_
#endif
#ifdef _PERMUTATION1_
    #define _GRADIENTMASK_
#endif
#ifdef _PERMUTATION2_
    #define _GRIDMASK_
#endif







#define GAUSS_KERNEL 9
#define HALF_KERNEL float(GAUSS_KERNEL / 2.0f)

#include <include/common.almfx>

struct GaussKernel
{
    float weights[GAUSS_KERNEL + 1];
};


RWStructuredBuffer<GaussKernel> gaussian : register(u0, space1);


float GaussianDistribution(float x, float dispersion)
{
    float g = 1.0f / (dispersion * 2.50662827463f);
    g *= exp(-(x * x) / (2.0f * dispersion * dispersion));
    return g;
}

float GenerateMainMask(float2 tc)
{
    return tc.x > 0.5f;
}

float GenerateCosMask(float2 tc)
{
    const float pi2 = 6.28318530718f;
    return (cos(tc.x * 4 * pi2) + 1.0f) / 2.0f;
}

float GenerateGradientMask(float2 tc)
{
    return tc.x / 2.0f;
}

float GenerateGridMask(float2 tc)
{
    const float pi2 = 6.28318530718f;
    return sin(tc.x * pi2) * cos(tc.y * pi2);
}

[numthreads(32, 32, 1)]
void MainCS(uint2 tid : SV_DispatchThreadID)
{
    const uint width = PerFrame.screenSize.x;
    const uint height = PerFrame.screenSize.y;

    if (tid.x < width && tid.y < height)
    {
        float2 tc = float2(tid) / float2(width, height);
        float mask = 0;
#if defined(_COSMASK_)
        mask = GenerateCosMask(tc);
#elif defined(_GRADIENTMASK_)
        mask = GenerateGradientMask(tc);
#elif defined(_GRIDMASK_)
        mask = GenerateGridMask(tc);
#else
        mask = GenerateMainMask(tc);
#endif
        
        float fWeightSum = 0;
        for (uint i = 0; i <= GAUSS_KERNEL; ++i)
        {
            const float weight = GaussianDistribution(float(i) - HALF_KERNEL, max(mask * 10.0f, 1.0f));
            gaussian[tid.x * height + tid.y].weights[i] = weight;
            fWeightSum += weight;
        }
        
        for (uint j = 0; j <= GAUSS_KERNEL; ++j)
        {
            gaussian[tid.x * height + tid.y].weights[j] /= fWeightSum;
        }
    }
}